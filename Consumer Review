//NOTE: WHEN "MAIN" IS WRITTEN, PUT THAT IN THE MAIN METHOD
//Activity 1

/*MAIN*/Review rev=new Review();double x=rev.sentimentVal("abandoned");

/*ANSWERS FOR FRQ
  *1.a.  public static double sentimentVal( String word )
  *1.b. yes, String
  *1.c. yes, double
  *3.a. yes because it's a string
  *3.b. yes, though it's a number, it will be interpreted as a string
  *3.c. no, there are too many paramers here
*/

//Activity 2

/*MAIN*/Review x=new Review();System.out.print(x.starRating("ReviewSample1.txt"));
/*in class*/public static int starRating(String fileName){if(sentimentVal(textToString(fileName))<-10){return 0;}else if(sentimentVal(textToString(fileName))>25){return 4;}else if(sentimentVal(textToString(fileName))>10){return 3;}else if(sentimentVal(textToString(fileName))>0){return 2;}else{return 1;}}

/*ANSWERS FOR FRQ
  *4. It will first call the textToString method to turn the text in the file into a string. Then will call the sentimentVal method which will return the numeric value of the text, then will return the numeric value to however it was called.
  *5.a. It doesn't make sense due to the weird numbers given to certain words which is beyond my control
  *5.b. by adjusting either the csv file or by making the result more specific in order to better receive results.
  *6.a. The error made in the program was the order in which the if statement was made.
  *6.b. Reverse the order in which the if statements are ordered.
*/

//Activity 3

/*MAIN*/Review x=new Review();System.out.println(x.fakeReview("SimpleReview.txt"));
/*in class*/String x=textToString(fileName).replaceAll(",","");String y=textToString("negativeAdjectives.txt");String z=textToString("positiveAdjectives.txt");String[] ar=z.split(" ");String[] arr=x.split(" ");x="";for(int i=0;i<arr.length;i++){if(y.indexOf(arr[i])!=-1&&arr[i].length()>2){arr[i]=ar[((int)(Math.random()*ar.length))];}x+=arr[i]+" ";}return x;

/*ANSWERS FOR FRQ
  *3. The indexOf method is designed to find the index value in a string that matches the parameters which may consist of another string, an integer, two integers, and an integer and string(the second integer is for starting at a certain index). This method can be helpful when trying to find a specific part of the string without hardcoding any point. The substring method is used to receive a truncated version of a given string, unlike trim or split, "substring" takes in two integers and cuts the string down to the points where the two integers are located, this in turn, returns a string which is smaller than the initial string given to the method. It is important to add 1 to the string when truncating it because substring cuts off the string at the point before the second index.
  *5. Static methods are only capable of accessing other static methods while non-static methods can access either or. Along with this,Â  to call to static methods does not require the use of an object due to the consistent nature of the method.
  *6. An effective way to make a review either a fake positive or a fake negative is by changing the words to match those of the review that you'd rather have by having a word bank that the function will look through and replace the opposing words in the review with.
*/

//Activity 4

/*MAIN*/Review x=new Review();System.out.println(x.extremeFakeReview("SimpleReview.txt"));
/*in class*/String x=textToString(fileName).replaceAll(",","");String y=textToString("cleanSentiment.csv").replaceAll("[0-9]","");String z=textToString("positiveAdjectives.txt");String[] ar=z.split(" ");String[] arr=x.split(" ");x="";for(int i=0;i<arr.length;i++){if(y.indexOf(arr[i])!=-1&&arr[i].length()>2){arr[i]=ar[((int)(Math.random()*ar.length))];}x+=arr[i]+" ";}return x;

/*ANSWERS FOR FRQ
  *1. A logical reason to autogenerate a negative review would be to conceal the use of autogenerated positive reviews which can make it seem that more people have been to an establishment with a larger variety of experiences.
  *2. A logical reason to autogenerate a positive review is so the establishment will seem as if they have received more positive feedback for their service than what has actually been said.
  *3. The method creates a string named x which is the contents of the file inputted except it removes all of the commas. Then the method creates a string named y which turns the entire "cleanSentiment.csv" into a string and removes all the numbers. After that, the method creates a third string named z which is the "positiveAdjectives.txt" in string format. After that, two string arrays are created that contain a different word in each of its contents, one splitting x, and one splitting z. Upon this, x is set to an empty string. Then the method checks and replaces all cases of a negative word with a random case of a positive word as provided in the "positiveAdjectives.txt". Then the method returns x.
  *5. This will cause oneWord to lose the character at the index of 0.
  *6. It's necessary to remove the '*' since when you'll be checking the file, you will also be checking the file for the character '*' and because of that, it won't be possible to find any words unless the given word has a '*' already in it.
  *7. By making the word bank in which it derives its words from have more positive adjectives.
*/

//Activity 5

import java.util.Scanner;import java.lang.Math;import java.util.ArrayList;class consumerReviewProgram{private double a1,b1,c1,m,b2;public static void main(String[] args){Scanner scan=new Scanner(System.in);consumerReviewProgram x=new consumerReviewProgram();String choice="";do{System.out.println("would you like to solve for linear and quadratic equations(lqr) or just factor(fql)");choice=scan.nextLine();if(choice.toLowerCase().contains("lqr")){System.out.println(x.lqr_solve()+"\n\n");}else if(choice.toLowerCase().contains("fql")){System.out.println(x.fql_solve()+"\n\n");}}while(choice.toLowerCase().contains("stop"));scan.close();}public void setNums(String choice){Scanner scan=new Scanner(System.in);if(choice.contains("a")){System.out.print("A: ");a1=scan.nextDouble();}if(choice.contains("b")){System.out.print("B: ");b1=scan.nextDouble();}if(choice.contains("c")){System.out.print("C: ");c1=scan.nextDouble();}if(choice.contains("d")){System.out.print("m: ");m=scan.nextDouble();}if(choice.contains("e")){System.out.print("other b: ");b2=scan.nextDouble();}scan.close();}public String fql_solve(){setNums("abc");double[] factor=factorx(a1,b1,c1);return "\n\n\nx = "+factor[0]+"\nx = "+factor[1];}public String lqr_solve(){setNums("abcde");c1-=b2;b1-=m;double[] factor=factorx(a1,b1,c1);return "\n\n\n("+factor[0]+" , "+(m*factor[0]+b2)+")\n("+factor[1]+" , "+(m*factor[1]+b2)+")";}public double[] factorx(double x,double y,double z){a1=x;b1=y;c1=z;double a=a1*c1;double x_one=0;double x_two=0;System.out.println(a);while((x_one*x_two!=a&&x_one+x_two!=b1)||a==0){if(a>0){while(x_one<a){x_two=1;while(x_two<a){x_two++;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one==x_two){break;}}if(x_one*x_two==a&&x_one+x_two==b1){break;}x_one*=-1;x_two=1;while(x_two<a){x_two++;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one==x_two){break;}}if(x_one*x_two==a&&x_one+x_two==b1){break;}x_one*=-1; x_one++;System.out.println(x_one+" "+x_two);if(x_one==x_two){break;}}}else if(a==0){x_one=0;x_two=b1;break;}else{while(x_one>a&&x_one<Math.abs(a)){x_two=1;while(x_two>a&&x_two<Math.abs(a)){x_two++;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one==x_two){break;}}if(x_one*x_two==a&&x_one+x_two==b1){break;}x_one*=-1;x_two=1;while(x_two>a&&x_two<Math.abs(a)){x_two++;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one==x_two){break;}}if(x_one*x_two==a&&x_one+x_two==b1){break;}x_one*=-1;x_one++;System.out.println(x_one+" "+x_two);if(x_one==x_two){break;}}}}x_one=-(x_one)/a1;x_two=-(x_two)/a1;System.out.printf("%.2f %.2f",x_one,x_two);double[] d={x_one,x_two};return d;}}

/*ANSWERS FOR FRQ
  *1. I chose to implement this program in order to help others with more difficult algebra problems since this is able to factor two numbers
  *2. I did a math problem on paper and followed that step-by-step while implementing it into the program.
  *3. public double[] factorx(double x,double y,double z){ . I chose the given parameters because then the program would be able to function as earlier mentioned, without the 3 numbers, factoring would be impossible. I made it non-static because it takes extra coding space.
  *4. I used two string methods in this class, ".contains" and ".toLowerCase", I used the first one to see if the string given contains a certain character and returns a boolean in order to make a scanner for the given character. Then I use the other one to standardize the answer given to make sure it becomes all lowercase which returns the initial string in all lower case to save coding space by A LOT.
  *5. while((x_one*x_two!=a&&x_one+x_two!=b1)||a==0){if(a>0){ while(x_one<a){x_two=1;while(x_two<a){x_two++;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one==x_two){break;}}if(x_one*x_two==a&&x_one+x_two==b1){break;}x_one*=-1;x_two=1;while(x_two<a){x_two++;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one==x_two){break;}}if(x_one*x_two==a&&x_one+x_two==b1){break;}x_one*=-1;x_one++;System.out.println(x_one+" "+x_two);if(x_one==x_two){break;}}}else if(a==0){x_one=0;x_two=b1;break;}else{while(x_one>a&&x_one<Math.abs(a)){x_two=1;while(x_two>a&&x_two<Math.abs(a)){x_two++;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one==x_two){break;}}if(x_one*x_two==a&&x_one+x_two==b1){break;}x_one*=-1;x_two=1;while(x_two>a&&x_two<Math.abs(a)){x_two++;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one*x_two==a&&x_one+x_two==b1){break;}x_two*=-1;if(x_one==x_two){break;}}if(x_one*x_two==a&&x_one+x_two==b1){break;}x_one*=-1;x_one++;System.out.println(x_one+" "+x_two);if(x_one==x_two){break;}}}} can easily be replaced by for(int i=0;i!=a1/2;i++){if(a1%i==0&&a1/i+i==b1){x_one=i;x_two=a1/i;break;}i*=-1;if(a1%i==0&&a1/i+i==b1){x_one=i;x_two=a1/i;break;}a1*=-1;if(a1%i==0&&a1/i+i==b1){x_one=i;x_two=a1/i;break;}i*=-1;if(a1%i==0&&a1/i+i==b1){x_one=i;x_two=a1/i;break;}a1*=-1;System.out.println(a1+" "+i);} to save extra efficiency and spacing.
  *6. do{System.out.println("would you like to solve for linear and quadratic equations(lqr) or just factor(fql)");choice=scan.nextLine();if(choice.toLowerCase().contains("lqr")){System.out.println(x.lqr_solve()+"\n\n");}else if(choice.toLowerCase().contains("fql")){System.out.println(x.fql_solve()+"\n\n");}}while(!choice.toLowerCase().contains("stop")); can be replaced by while(!choice.toLowerCase().contains("stop")){System.out.println("would you like to solve for linear and quadratic equation (lqr) or justfactor(fql)");choice=scan.nextLine();if(choice.toLowerCase().contains("lqr")){System.out.println(x.lqr_solve()+"\n\n");}else if(choice.toLowerCase().contains("fql")){System.out.println(x.fql_solve()+"\n\n");}}
*/
